#!/usr/bin/env python
#import numpy as np
#import cv2
#from cv_bridge import CvBridge, CvBridgeError
import roslib
import rospy
import tf2_ros
import tf2_msgs
import math
import json
import tf2_geometry_msgs
from std_msgs.msg import Int32MultiArray
from geometry_msgs.msg import TransformStamped, Vector3
from geometry_msgs.msg import PoseStamped
from tf.transformations import quaternion_from_euler,euler_from_quaternion


boxes_msg = None

def callback(msg):
	global boxes_msg
	boxes_msg = msg
	return


rospy.init_node("sign_tf")
box_sub = rospy.Subscriber('sign_box', Int32MultiArray, callback)
br = tf2_ros.TransformBroadcaster()
tf_buf   = tf2_ros.Buffer()
tf_lis = tf2_ros.TransformListener(tf_buf, queue_size=10)


fy = 220.72391163
fx = 221.88078347
real_size = 0.2
H, W = 446, 332  #size of undist images

#get all the signs in the map
w_name = rospy.get_param(rospy.get_name() + "/world_name")
with open(w_name, 'rb') as f:
	world = json.load(f)
signs = [s['sign'] for s in world['roadsigns']]


label_file_name = rospy.get_param(rospy.get_name() + '/labels')
rospy.loginfo('reading label file: '+label_file_name)
with open(label_file_name, 'rb') as f:
	labels = f.read().strip().split("\n")
	rospy.loginfo('reading labels:')

def main():
	global boxes_msg
	rate = rospy.Rate(10) #Hz
	while not rospy.is_shutdown():
		if boxes_msg:
			boxes = boxes_msg
			n = boxes.layout.dim[1].size  #7: [centerX, centerY, id(14 now), height, width, stamp, stamp_ns]
			boxes_msg = None

			#calculate the complete tf of the object(s)

			for i in range(boxes.layout.dim[0].size):
				p = PoseStamped()
				p.header.frame_id = 'cf1/camera_link'

				p.header.stamp.secs = boxes.data[n*i+5]
				p.header.stamp.nsecs = boxes.data[n*i+6]

				#find the depth of found object(s)

				p.pose.position.z = fy*real_size/(boxes.data[n*i+3])  
				p.pose.position.x = (boxes.data[n*i]-W/2)*p.pose.position.z/fx
				p.pose.position.y = (boxes.data[n*i+1]-H/2)*p.pose.position.z/fy
				
				m_class = labels[boxes.data[n*i+2]]
				yaw_detected = math.pi/2 - math.asin(boxes.data[n*i+4]/real_size) #value between pi/2 and 0


				#find orientation:
				if m_class in signs: #if it exist in the map
					#Transform the map pose of the sign_detected in the same frame
					try:
						trans = tf_buf.lookup_transform("cf1/camera_link", 'sign/' + m_class, rospy.Time())
					except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
						rate.sleep()
						continue

					if len(trans)!=0: #shouldn't be a problem here 
						yaw_map = euler_from_quaternion(trans[-1].transform.rotation)[0]
						if abs(yaw_map-yaw_detected) > yaw_map+yaw_detected :
							yaw_detected = -yaw_detected
							
						roll, pitch, yaw = yaw_detected + 90, 90, 0  #weird axis definition..  +90??
						(p.pose.orientation.x,
    					 p.pose.orientation.y,
    					 p.pose.orientation.z,
    					 p.pose.orientation.w) = quaternion_from_euler(math.radians(roll),
                                                    					 math.radians(pitch),
                                                    					 math.radians(yaw))

				if not tf_buf.can_transform('map', 'cf1/camera_link', rospy.Time(0)):
					rospy.logwarn_throttle(5.0, 'No transform from cf1/camera_link to map')
					return

				p = tf_buf.transform(p, 'map')

				t = TransformStamped()
				t.header.stamp = p.header.stamp
				t.header.frame_id = 'map'
				t.child_frame_id = 'sign_dectected/' + labels[boxes.data[n*i+2]]
				t.transform.translation = p.pose.position
				t.transform.rotation = p.pose.orientation
				br.sendTransform(t)

		rate.sleep()
	return

if __name__ == '__main__':
	main()
